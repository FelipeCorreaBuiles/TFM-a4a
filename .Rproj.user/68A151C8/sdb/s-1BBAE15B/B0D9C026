{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n# \n# http://www.rstudio.com/shiny/\n#\n## try http:// if https:// URLs are not supported\n#source(\"https://bioconductor.org/biocLite.R\")\n#biocLite(\"tkWidgets\")\n#shiny::runApp(port = 7775,host = '192.168.1.24',display.mode = 'showcase')\nlibrary(shiny)\nlibrary(cluster)\nlibrary(ggplot2)\nlibrary(Cairo) \nlibrary(GGally)\nlibrary(Hmisc)\nlibrary(pastecs)\nlibrary(psych)\nlibrary(corrgram)\nlibrary(corrplot)\nlibrary(caret)\nlibrary(rpart.plot)\nlibrary(e1071)\nlibrary(kernlab)\nlibrary(pROC)\nlibrary(gdata)\n\n#library(rattle)\n#install.packages(\"rattle\")\n\n\n#library(tkWidgets)\n#options(shiny.trace=FALSE)\n# By default, the file size limit is 5MB. It can be changed by\n# setting this option. Here we'll raise limit to 9MB.\noptions(shiny.maxRequestSize = 100*1024^2)\n\n\nshinyServer(\n  function(input, output, session) {\n    par(bg=NA)\n    \n    ##################################################\n    #                 INICIO GRAFICOS               #\n    #################################################\n    ranges <- reactiveValues(x = NULL, y = NULL)\n    \n    output$scatter_plot <- renderPlot({\n      ggplot(readfile(), aes_string(input$x_col, input$y_col)) +\n        geom_point(aes_string(colour = input$color_scatter)) +\n        coord_cartesian(xlim = ranges$x, ylim = ranges$y)+ \n        ggtitle(input$scatter_titulo)+\n        xlab(input$scatter_xlab) +\n        ylab(input$scatter_ylab) \n    })\n    \n    # When a double-click happens, check if there's a brush on the plot.\n    # If so, zoom to the brush bounds; if not, reset the zoom.\n    observeEvent(input$scatter_plot_dblclick, {\n      brush <- input$scatter_plot_brush\n      if (!is.null(brush)) {\n        ranges$x <- c(brush$xmin, brush$xmax)\n        ranges$y <- c(brush$ymin, brush$ymax)\n        \n      } else {\n        ranges$x <- NULL\n        ranges$y <- NULL\n      }\n    })\n   \n      \n    \n    output$x_col <- renderUI({\n      #if(is.null(input$variables)){ \n      colnames <- varlist(readfile(),type=\"numeric\")\n      #}else{\n      # colnames <-input$variables\n      #}\n      selectInput('x_col', 'Variable del eje X', colnames,colnames[1])\n     \n      \n    })\n    output$y_col <- renderUI({\n      #if(is.null(input$variables)){ \n      colnames <- varlist(readfile(),type=\"numeric\")\n      #}else{\n      # colnames <-input$variables\n      #}\n      \n      selectInput('y_col', 'Variable del eje Y', colnames,colnames[2])\n      \n    })\n    \n    output$scatter_xlab <- renderUI({\n      textInput(\"scatter_xlab\", \"Etiqueta para el eje X\", input$x_col)\n    })\n    output$scatter_ylab <- renderUI({\n      textInput(\"scatter_ylab\", \"Etiqueta para el eje Y\", input$y_col)\n    })\n    output$color_scatter <- renderUI({\n      #if(is.null(input$variables)){ \n      colnames <- varlist(readfile(),type=\"factor\")\n      #}else{\n      # colnames <-input$variables\n      #}\n      \n      selectInput('color_scatter', 'Seleccione una variable para el color', colnames)\n      \n    })\n    ##scatter matrix\n    \n    \n    \n    output$matrix_menu <- renderUI({\n      colnames <- names(readfile())\n    selectizeInput(\"matrix_vars\", \"Seleccione las variables para visualizar:\",\n                   colnames,multiple = TRUE,options = list(maxItems = 3))\n    })\n    \n    output$color_matrix <- renderUI({\n      #if(is.null(input$variables)){ \n      colnames <- varlist(readfile(),type=\"factor\")\n      #}else{\n      # colnames <-input$variables\n      #}\n      \n      selectInput('color_matrix', 'Seleccione una variable para el color', colnames)\n      \n    })\n    \n    output$matrix_plot <- renderPlot({\n      \n      data<-readfile()[input$matrix_vars]\n        \n      \n      \n      #color=as.name(input$color) \n      #data[,color]<-as.factor(data[,color])\n      #\n      if(length(data)>0){\n        ###OPCIONAL\n        if(!input$color_matrix  %in%  input$matrix_vars){\n          data<-cbind(data,readfile()[input$color_matrix])\n        }\n        ###opcional\n        data[,input$color]<-as.factor(data[,input$color_matrix])\n        #\n        if(length(data)>1){\n          # list(continuous = wrap(\"density\", alpha = 0.5), combo = \"box\")\n          if(input$matrix_advance==2){\n        \n                if(input$show_lower == 1){\n                    lower = list( continuous = input$cont_lower, combo = input$combo_lower,discrete=input$discrete_lower)\n                }else{\n                  lower = \"blank\"\n                }\n                  \n                if(input$show_upper == 1){\n                    upper = list( continuous = input$cont_upper, combo = input$combo_upper,discrete=input$discrete_upper)\n                }else{\n                  upper = \"blank\"\n                }\n                if(input$show_diag == 1){\n                    diag = list( continuous = input$cont_diag,discrete=input$discrete_diag)\n                }else{\n                  diag = \"blank\"\n                }\n                \n                ggpairs(data, \n                        lower = lower,\n                        upper = upper,\n                        diag = diag,\n                        mapping = ggplot2::aes_string(color = input$color_matrix))#color='Species', alpha=0.4)\n          }else{\n                ggpairs(data, \n                    mapping = ggplot2::aes_string(color = input$color_matrix))#color='Species', alpha=0.4)\n                \n          }\n        }\n      }\n      \n    })\n   \n    \n \n    \n    ##################################################\n    #                 FIN GRAFICOS               #\n    #################################################\n  \n  readfile<-eventReactive(input$leerArchivo,{\n    inFile<-input$file1\n    \n    if (is.null(inFile))\n      return(NULL)\n    \n    if(input$auto_reading==TRUE){\n    \n        separador=input$sep\n        \n        if(separador=='otro'){\n          separador=input$otro_sep\n        }\n       \n         data<-read.csv(inFile$datapath, header = input$header,\n                 sep = separador, quote = input$quote,dec = input$decimal,stringsAsFactors=input$string_as_factors)\n         \n    }else{\n      metadata = getFileMetaData(inFile$datapath, numLine = 200, isFile = TRUE)\n      sepa = metadata$separator\n      \n      #print(metadata)\n      headera = metadata$header\n      print(sepa)\n      print(headera)\n      data<-read.csv(inFile$datapath, \n               header = headera,\n               sep = sepa,\n               quote = '\"',\n               dec = '.',\n               stringsAsFactors=TRUE)\n      trim(data)\n      \n      }\n   }\n    \n    \n    )\n  \n  output$contents <- renderDataTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, it will be a data frame with 'name',\n    # 'size', 'type', and 'datapath' columns. The 'datapath'\n    # column will contain the local filenames where the data can\n    # be found.\n    \n     data<- readfile() \n     if(!(is.null(readfile()))){\n       #if(input$vars_edit==TRUE){\n       if(!is.null(input$variables)){\n         data<-data[input$variables]\n         colnames <- names(data)\n         colname_alter = c()\n         \n         for(i in 1:ncol(data)){\n           nam = paste0(\"ren-\",colnames[i])\n           type<-paste0(\"tipo-\",colnames[i])\n           if(!(is.null(nam)|| nam=='ren-')){\n           colname_alter<-c(colname_alter,input[[nam]])\n           }\n         }\n         \n         if(length(colname_alter)==length(colnames)){\n          print(colname_alter)\n          names(data)<-colname_alter\n         }\n         \n         #readfile()<-data\n       }\n       #}\n     }\n     \n     head(data, 20)\n   #head(data, 20)\n  }, options = list(scrollX = TRUE , pageLength = 10))\n  \n  output$VarControls <- renderUI({\n      #if(is.null(input$variables)){ \n    colnames <- names(readfile())\n    #}else{\n     # colnames <-input$variables\n    #}\n    \n    cbg<-checkboxGroupInput(\"variables\", \"\", choices = colnames,selected = colnames,inline = FALSE,width = NULL)\n    #print (cbg)\n    cbg\n    \n  })\n  output$VarControls_rename <- renderUI({\n    colnames <- names(readfile())\n    #cbg<-checkboxGroupInput(\"variablesXXX\", \"\", choices = colnames,selected = colnames,inline = FALSE,width = NULL)\n    #print(list(colnames))\n    textIn <- list()\n    #print (colnames[1])\n  for(i in 1:ncol(readfile())){\n    #print (colnames[i])\n    ti<-textInput(inputId = paste0(\"ren-\",colnames[i]),label=colnames[i],value = colnames[i],width = NULL)\n    var_type<-ifelse(is.numeric(readfile()[,colnames[i]]),'numeric','factor')\n    si<-selectizeInput(inputId = paste0(\"tipo-\",colnames[i]), label=NULL, choices=c('Tipo Numérico'='numeric','Tipo Categórico'='factor'), selected = var_type, multiple = FALSE,options = NULL)\n    #cbi<-checkboxInput(inputId = paste0(\"incluir-\",colnames[i]), label=colnames[i], value = TRUE, width = NULL)\n    #print(ti)\n    #print(si)\n    #print((typeof()))\n    #textIn <- list(textIn, list(cbi))\n     \n    textIn <- list(textIn, list(ti))\n    textIn <- list(textIn, list(si))\n    textIn <- list(textIn, list(tags$hr()))\n    \n   \n  }\n    tagList(\n    textIn\n    )\n  \n  })\n  \n  output$groupby <- renderUI({\n    colnames <- input$variables\n    checkboxGroupInput(\"groupby\", \"Campos de Agrupación\", choices = input$variables)\n    \n  })\n  \n  output$aggregationColumns <- renderUI({\n    \n    checkboxGroupInput(\"aggregationColumns\", \"Columnas a Calcular\", choices = input$variables)\n    \n  })\n  \n  output$aggMethods <- renderUI({\n    colnames <- input$variables\n    checkboxGroupInput(\"aggMethods\", \"Selecciona la funcion de Agregación\", choices = c('Sum','Mean','SD','Count'))\n    \n  })\n  \n  output$contents_pre<-renderDataTable({\n    data<- readfile()\n    data<-data[input$variables]\n    head(data, 20)\n    \n  }, options = list(scrollX = TRUE, pageLength = 10))\n  \n  output$summary_vars<-renderDataTable({\n   if(!(is.null(readfile()))){\n     if(input$summary_method=='basico'){\n       data_render<-readfile()\n       #flag = c(paste(sep = \"\",'<img src=\"', 'shared/tempImages/',basename(generateImage(data_render[2])),'\" height=\"200\"></img>'),\n       #        '<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Flag_of_the_People%27s_Republic_of_China.svg/200px-Flag_of_the_People%27s_Republic_of_China.svg.png\" height=\"52\"></img>',\n       #         '<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Flag_of_the_People%27s_Republic_of_China.svg/200px-Flag_of_the_People%27s_Republic_of_China.svg.png\" height=\"52\"></img>'\n      # )\n       summ<-summary(readfile())\n       #cbind(summ,flag)\n     }else{\n       #if(input$summary_method=='hmisc'){\n         #Hmisc::describe(readfile())\n      # }else{\n       \n         if(input$summary_method=='pastecs'){\n           summ <- t(stat.desc(readfile())) \n           summ <- cbind(Variable = rownames(summ), summ)\n           \n         }else{\n           if(input$summary_method=='psych'){\n             summ<-psych::describe(readfile())\n             summ <- cbind(Variable = rownames(summ), summ)\n             summ\n             }\n       #  }\n       }\n     }\n    }\n  }, options = list(scrollX = TRUE,pageLength = 10,bFilter=0, bSort=0, bProcessing=0, bPaginate=0, bInfo=0),escape = FALSE)\n  \n  \n  correlations_chart<-eventReactive(input$do_correlation,{\n    data<-readfile()\n    par(bg=NA)\n    par(c(5.1, 4.1, 6.1, 2.1))\n    #corrgram(data, order=TRUE, lower.panel=panel.shade,\n     #        upper.panel=panel.pie, text.panel=panel.txt,\n             #main=\"Correlaciones\")\n    colnames <- varlist(readfile(),type=\"numeric\")\n    M<-cor(data[colnames])\n    col <- colorRampPalette(c(\"#BB4444\", \"#EE9988\", \"#FFFFFF\", \"#77AADD\", \"#4477AA\"))\n    corrplot(M, method=\"color\", col=col(200),  \n             type=\"upper\", order=\"hclust\", \n             addCoef.col = \"black\", # Add coefficient of correlation\n             tl.col=\"black\", tl.srt=45, #Text label color and rotation\n             # Combine with significance\n             #p.mat = p.mat, sig.level = 0.01, insig = \"blank\", \n             # hide correlation coefficient on the principal diagonal\n            tl.pos = \"lt\",\n             diag=FALSE ,\n             bg = \"transparent\"\n             \n            # title=\"Correlaciones de Variables\"\n    )\n    \n  })\n  output$out_plot_correlations <- renderPlot({\n    correlations_chart()\n  },bg=\"transparent\")\n  \n  \n  na_fix<-eventReactive(input$do_na_fix,{\n    string_fix = input$string_na\n    numeric_fix = input$numeric_na\n    data <- readfile()\n    \n    if(string_fix != 'nothing' | numeric_fix != 'nothing'){\n        \n        colnames_string <- varlist(data,type=\"factor\")\n        colnames_char <- varlist(data,type=\"character\")\n        colnames_numeric <- varlist(data,type=\"numeric\")\n        \n        if(string_fix == 'erase_row'){\n          remove_nas<-which(complete.cases(data[colnames_string]))\n          data<-data[remove_nas,]\n          remove_nas<-which(complete.cases(data[colnames_char]))\n          data<-data[remove_nas,]\n        }\n        \n        if(numeric_fix == 'erase_row'){\n          remove_nas<-which(complete.cases(data[colnames_numeric]))\n          data<-data[remove_nas,]\n        }\n    }\n    data\n  })\n  \n  output$na_fix_table<-renderDataTable({\n    na_fix()\n  }, options = list(scrollX = TRUE, pageLength = 10))\n  \n    \n  \n    \n  \n  \n  \n  \n  output$summary<-renderDataTable({\n    applyAggreg()\n  }, options = list(scrollX = TRUE, pageLength = 10))\n  \n  applyAggreg<-eventReactive(input$ApplyAgg,{\n    sALL(readfile(),input)\n  })\n  \n  output$ModelVarControls <- renderUI({\n    if(is.null(input$aggMethods)){ \n        colnames <-input$variables\n      }else{\n        colnames <-names(applyAggreg())\n      }\n    checkboxGroupInput(\"model_variables\", \"Seleccione las variables que serán utilizadas en el Modelo a entrenar\", choices = colnames,selected = colnames)\n  })\n  \n  transform_model_data<-eventReactive(input$do_model_var_transform,{\n    data=''\n    if(is.null(input$aggMethods)){ \n      data<- readfile()\n    }else{\n      data <- applyAggreg()\n    }\n    data = data[input$model_variables]\n    \n    if(input$nulos==TRUE){  \n      data<-data[complete.cases(data),]      \n    }\n    if(input$scale_on==TRUE){  \n       data<-scale(data)        \n    }\n    as.data.frame(data)\n  })\n  \n  output$modified_final_vars<-renderDataTable({\n    head(transform_model_data(),5)\n  }, options = list(scrollX = TRUE , pageLength = 10))\n  \n  \n  cluster_test<-eventReactive(input$do_cluster_test,{\n    set.seed(-1785)\n    number_clusters_validation_I <- input$number_clusters_validation[1]\n    number_clusters_validation_F <- input$number_clusters_validation[2]\n    data <-transform_model_data()\n    #print(data)\n    subset<-data[input$model_variables]\n   # print(\"Entrando a cluster\")\n    #print(subset)\n    wss <- (nrow(subset)-1)*sum(apply(subset,2,var))\n    for (i in number_clusters_validation_I:number_clusters_validation_F) wss[i] <- sum(kmeans(subset, \n                                                                 centers=i)$withinss)\n    plot(1:number_clusters_validation_F, wss, type=\"b\", xlab=\"Number of Clusters\",\n         ylab=\"Within Groups Sum of Squares\")\n    #print(\"saliendo de cluster\")\n  })\n  \n  output$numberOfClusters<-renderPlot({\n    cluster_test()\n  })\n  \n  cluster_generate<-eventReactive(input$do_cluster,{\n    set.seed(-1785) \n    subset<-transform_model_data()\n    fit <- kmeans(subset, input$number_centers)\n   })\n  \n  #plot cluster fitted\n  \n  output$centers <- renderDataTable({\n    fit<-cluster_generate()\n    fit$centers\n  }, options = list(scrollX = TRUE,pageLength = 10))\n    #Plot Cluster distribution\n  output$clusters<-renderPlot({\n    fit<-cluster_generate()\n    par(mar = c(5, 4, 6, 2))\n    height <- table(fit$cluster)\n    mp <- barplot(height, main = \"Clusters Distribution\",xlab=\"Cluster\",ylab=\"Number of Rows\")\n    text(mp, height, labels = format(height, 2), pos = 1, cex = 0.9)\n  })\n    #Creating fitted cluster plot\n  output$fitCluster<-renderPlot({\n    subset<-transform_model_data()\n    fit<-cluster_generate()\n    clusplot(subset, fit$cluster, color=TRUE, shade=TRUE, \n             labels=4, lines=0)\n  })\n  \n  output$out_class_var <- renderUI({\n    #if(is.null(input$variables)){ \n    colnames <- varlist(readfile(),type=\"factor\")\n    #}else{\n    # colnames <-input$variableslibrary\n    #}\n    \n    selectInput('class_var_out', 'Seleccione la variable Objetivo del modelo', colnames,multiple = FALSE)\n    \n  })\n  ##Variable clasificacion arbol\n  \n  output$choose_columns_classify <- renderUI({\n    # If missing input, return to avoid error later in function\n    if(is.null(input$file1))\n      return()\n    \n    # Get the data set with the appropriate name\n    dat <- readfile()\n    colnames <- names(dat)\n    \n    # Create the checkboxes and select them all by default\n    checkboxGroupInput(\"predict_columns\", \"Seleccione las variables predictoras\", \n                       choices  = colnames,\n                       selected = colnames)\n  })\n  \n  #predict_columns\n  #class_var_out\n  \n  classify_models<-eventReactive(input$do_classify,{\n  #fitControl <- trainControl(method = \"repeatedcv\",\n   #                          number = 3,\n  #                          repeats = 2, returnResamp=\"all\",classProbs = TRUE)\n  ctr <- trainControl(method='cv',\n                      number=input$train_cv, \n                      classProbs=TRUE\n                      #summaryFunction=twoClassSummary \n  )\n  \n  set.seed(3456)\n  data = readfile()\n  trainIndex <- createDataPartition(data[,input$class_var_out], p = (input$train_percent/100),\n                                    list = FALSE,\n                                    times = 1)\n  data_train = readfile()[trainIndex,]\n  \n  \n  # Choose the features and classes\n  #library(mlbench)\n  #data(PimaIndiansDiabetes2)\n  #x <- PimaIndiansDiabetes2[c(\"age\",\"glucose\",\"insulin\",\"mass\",\"pedigree\",\"pregnant\",\"pressure\",\"triceps\")]\n  #y <- PimaIndiansDiabetes2$diabetes\n  x<-subset(data_train, select = input$predict_columns)\n  print(input$predict_columns)\n  y<-as.factor(unlist( subset(data_train,select=input$class_var_out)))\n # y<-as.factor(y)\n  # print(typeof(y))\n  #  print(input$class_var_out)\n  # print(\"Numero x y y\")\n  #  print(nrow(x))\n  #  print(nrow(y))\n  #grid <- expand.grid( .winnow = c(TRUE,FALSE), .trials=c(1,5,10,15,20), .model=\"tree\" )\n  print(\"modelando\")\n  print(nrow(data_train))\n  \n # mdl<- train(x=x,y = data_train$Species,trControl=fitControl,method=\"rpart\",verbose=FALSE)\n  #mdl = train (x=x,\n       #        y = data_train$Species,\n    #             #method = \"rpart\",\n         #        tuneLength=20,\n           #      metric=\"ROC\",\n            #     trControl = fitControl)\n # data(iris)\n  #formula <- as.formula(Species ~.)\n  f <- as.formula(paste(input$class_var_out, \"~\", paste(input$predict_columns, collapse=\" + \")))\n  #print(f)\n  set.seed(178509)\n  withProgress(message = 'Generando Modelo De Arbol', value = 0, {\n    # Number of times we'll go through the loop\n    incProgress(1, detail = \"...\")\n    \n    mdl <- train(f,data_train,method = \"rpart\",cp=0.02,maxdepth=20,trControl = ctr)\n    \n  })\n  \n  mdl\n  \n  # visualize the resample distributions\n  #xyplot(mdl,type = c(\"g\", \"p\", \"smooth\"))\n  \n  })\n  classify_models_svm<-eventReactive(input$do_classify,{\n    set.seed(3456)\n    data = readfile()\n    trainIndex <- createDataPartition(data[,input$class_var_out], p = (input$train_percent/100),\n                                      list = FALSE,\n                                      times = 1)\n    data_train = readfile()[trainIndex,]\n\n  \n  \n  # Choose the features and classes\n  #library(mlbench)\n  #data(PimaIndiansDiabetes2)\n  #x <- PimaIndiansDiabetes2[c(\"age\",\"glucose\",\"insulin\",\"mass\",\"pedigree\",\"pregnant\",\"pressure\",\"triceps\")]\n  #y <- PimaIndiansDiabetes2$diabetes\n  #x<-subset(data_train, select = input$predict_columns)\n # print(input$predict_columns)\n    #y<-as.factor(unlist( subset(data_train,select=input$class_var_out)))\n  # y<-as.factor(y)\n    # print(typeof(y))\n    # print(input$class_var_out)\n    #print(\"Numero x y y\")\n    #print(nrow(x))\n    #print(nrow(y))\n  #grid <- expand.grid( .winnow = c(TRUE,FALSE), .trials=c(1,5,10,15,20), .model=\"tree\" )\n  print(\"modelando\")\n  print(nrow(data_train))\n  # mdl<- train(x=x,y = data_train$Species,trControl=fitControl,method=\"rpart\",verbose=FALSE)\n  #mdl = train (x=x,\n  #        y = data_train$Species,\n  #             #method = \"rpart\",\n  #        tuneLength=20,\n  #      metric=\"ROC\",\n  #     trControl = fitControl)\n  # data(iris)\n  #formula <- as.formula(Species ~.)\n  ctr <- trainControl(method='cv',\n                      number=input$train_cv, \n                      classProbs=TRUE\n                      #summaryFunction=twoClassSummary \n  )\n \n  f <- as.formula(paste(input$class_var_out, \"~\", paste(input$predict_columns, collapse=\" + \")))\n  #print(f)\n  set.seed(178509)\n  svp.c<-''\n  withProgress(message = 'Generando Modelo de SVM', value = 0, {\n    # Number of times we'll go through the loop\n    incProgress(1, detail = \"...\")\n    \n    #mdl <- train(f,data_train,method = \"rpart\",cp=0.002,maxdepth=20)\n    #mod <- train(f, data=data_train, method = \"svmLinear\", trControl = ctrl)\n    data_train[input$predict_columns]<-trim(data_train[input$predict_columns])\n    svp.c <- train(f, data=data_train,  method = \"svmLinear\",  \n                   trControl = ctr, \n                   preProcess = c('center', 'scale'),\n                   metric = \"ROC\")\n    \n  })\n  \n  svp.c\n  \n  })\n  \n  output$out_classify_chart<-renderPlot({\n    #library(rattle)\n    \n    print(classify_models())\n    #plot(classify_models()$finalModel)\n    draw_tree(classify_models()$finalModel,sub=\"-\")\n  },bg=\"transparent\")\n  output$out_classify_chart2<-renderPlot({\n    #library(rattle)\n    \n    print(classify_models_svm())\n    #plot(classify_models()$finalModel)\n    #kernlab::plot(classify_models_svm()$finalModel,data = readfile())\n    results <- resamples(list(TREE=classify_models(), SVM=classify_models_svm()))\n    # summarize the distributions\n    print(summary(results))\n    # boxplots of results\n    bwplot(results)\n  },bg=\"transparent\")\n  \n  output$trained_tree<-renderPlot({\n    if(is.null(classify_models()))\n        plot(classify_models())\n  },bg=\"transparent\")\n  \nconfusionMatrixTree<-eventReactive(input$do_classify,{\n    set.seed(3456)\n    data = readfile()\n    trainIndex <- createDataPartition(data[,input$class_var_out], p = (input$train_percent/100),\n                                      list = FALSE,\n                                      times = 1)\n    data_test = readfile()[-trainIndex,]\n    \n    tree<-classify_models()\n    #svm<-classify_models_svm()\n    \n    predictedTest_tree<-predict(tree,newdata = data_test)\n    #predictedTest_svm<-predict(svm,newdata = data_test)\n    \n    confusionMatrix(predictedTest_tree,data_test[,input$class_var_out])\n    #confusionMatrix(predictedTest_svm,data_test[,input$class_var_out])$table\n    \n    \n  })\n  \n  output$confusionMatrixTree_table<-renderTable({\n    confusionMatrixTree()$table\n  })\n  \n  output$confusionMatrixTree_byClass<-renderTable({\n    t(t(confusionMatrixTree()$overall))\n  })\n  \n  \n  \n  confusionMatrixSVM<-eventReactive(input$do_classify,{\n    set.seed(3456)\n    data = readfile()\n    trainIndex <- createDataPartition(data[,input$class_var_out], p = (input$train_percent/100),\n                                      list = FALSE,\n                                      times = 1)\n    data_test = readfile()[-trainIndex,]\n    \n    #tree<-classify_models()\n    svm<-classify_models_svm()\n    \n    #predictedTest_tree<-predict(tree,newdata = data_test)\n    predictedTest_svm<-predict(svm,newdata = data_test)\n    \n    #confusionMatrix(predictedTest_tree,data_test[,input$class_var_out])\n    confusionMatrix(predictedTest_svm,data_test[,input$class_var_out])\n    \n    \n  })\n  \n  output$confusionMatrixSVM_table<-renderTable({\n    confusionMatrixSVM()$table\n  })\n  \n  output$confusionMatrixSVM_byClass<-renderTable({\n    t(t(confusionMatrixSVM()$overall))\n  })\n    \n  \n  \n  \n  \n  })#FINFIN\n    \n  \n  \nsALL<-function(data,input){\n  \n  library(doBy)\n  \n  if(length(input$aggMethods)  == 1){\n    \n    if(is.element('Sum',input$aggMethods)){\n      return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                FUN = function(x) { c(sum = sum(x)) } ))\n      \n    }\n    if(is.element('Mean',input$aggMethods)){\n      return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                FUN = function(x) { c(mean = mean(x,na.rm = TRUE)) } ))\n    }\n    if(is.element('SD',input$aggMethods)){\n      return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                FUN = function(x) { c(sd = sd(x,na.rm = TRUE)) } ))\n    }\n    if(is.element('Count',input$aggMethods)){\n      return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                FUN = function(x) { c(count = length(x)) } ))\n    }\n  }else\n  {\n    if(length(input$aggMethods)==2 ){\n      \n      \n      if(is.element('Sum',input$aggMethods)& is.element('Count',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(sum = sum(x),count = length(x)) } ))\n      }\n      \n      if(is.element('Sum',input$aggMethods)& is.element('Mean',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(sum = sum(x),mean = mean(x,na.rm = TRUE)) } ))\n      }\n      \n      if(is.element('Sum',input$aggMethods)& is.element('SD',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(sum = sum(x),sd = sd(x,na.rm = TRUE)) } ))\n      }\n      \n      if(is.element('Mean',input$aggMethods)& is.element('Count',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(mean = mean(x,na.rm = TRUE),count = length(x)) } ))\n      }\n      \n      if(is.element('SD',input$aggMethods)& is.element('Count',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(sd = sd(x,na.rm = TRUE),count = length(x)) } ))\n      }\n      \n      if(is.element('Mean',input$aggMethods)& is.element('SD',input$aggMethods)){\n        return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                          FUN = function(x) { c(mean = mean(x,na.rm = TRUE),sd = sd(x,na.rm = TRUE)) } ))\n      }\n    }else{\n      if(length(input$aggMethods)==3){\n        \n        if(is.element('Sum',input$aggMethods) & is.element('Count',input$aggMethods) & is.element('Mean',input$aggMethods)){\n          return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                            FUN = function(x) { c(sum = sum(x),count = length(x),mean = mean(x,na.rm = TRUE)) } ))\n        }\n        \n        if(is.element('Sum',input$aggMethods) & is.element('Count',input$aggMethods) & is.element('SD',input$aggMethods)){\n          return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                            FUN = function(x) { c(sum = sum(x),count = length(x),sd = sd(x,na.rm = TRUE)) } ))\n        }\n        \n        if(is.element('Mean',input$aggMethods) & is.element('Count',input$aggMethods) & is.element('SD',input$aggMethods)){\n          return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                            FUN = function(x) { c(mean = mean(x,na.rm = TRUE),count = length(x),sd = sd(x,na.rm = TRUE)) } ))\n        }\n       \n        if(is.element('Mean',input$aggMethods) & is.element('Sum',input$aggMethods) & is.element('SD',input$aggMethods)){\n          return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                            FUN = function(x) { c(sum = sum(x),mean = mean(x,na.rm = TRUE),sd = sd(x,na.rm = TRUE)) } ))\n        }\n      }else{\n        if(length(input$aggMethods)==4){\n          \n          if(is.element('Sum',input$aggMethods) & is.element('Count',input$aggMethods) & is.element('Mean',input$aggMethods) & is.element('SD',input$aggMethods)){\n            return (summaryBy(list(input$aggregationColumns,input$groupby), data = data, \n                              FUN = function(x) { c(sum = sum(x),count = length(x),mean = mean(x,na.rm = TRUE),sd = sd(x,na.rm = TRUE)) } ))\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n}\nvarlist <- function (df=NULL,type=c(\"numeric\",\"factor\",\"character\"), pattern=\"\", exclude=NULL) {\n  vars <- character(0)\n  if (any(type %in% \"numeric\")) {\n    vars <- c(vars,names(df)[sapply(df,is.numeric)])\n  }\n  if (any(type %in% \"factor\")) {\n    vars <- c(vars,names(df)[sapply(df,is.factor)])\n  }  \n  if (any(type %in% \"character\")) {\n    vars <- c(vars,names(df)[sapply(df,is.character)])\n  }  \n  vars[(!vars %in% exclude) & grepl(vars,pattern=pattern)]\n}\n\ngetFileMetaData <- function(file.name, numLine = 100, seps, isFile = TRUE){\n  \n  separator <- \"\"\n  header <- FALSE\n  sep <- NULL\n  \n  if(missing(seps)){\n    seps <- c(\",\", \";\", \"\\t\",\" \") #\"\\\\t\", \" \")\n  }#else{\n  #    seps <- c(seps, \",\", \";\", \"\\t\", \" \")\n  #}\n  \n  if(isFile){\n    conn <- safeFileOpen(file.name)\n    if(inherits(conn, \"connection\")){\n      toCheck <- readLines(conn, n = numLine)\n      close(conn)\n    }else{\n      stop(paste(\"Can't read file because\", conn))\n    }\n  }else{\n    toCheck <- file.name\n  }\n  \n  good <- function(x) all(x==x[1]) && x[1] > 1\n  \n  for(i in seps){\n    w <- strsplit(toCheck[2:length(toCheck)], i)\n    v <- sapply(w, length)\n    if(good(v)){\n      sep <- i\n      break\n    }\n  }\n  if(!is.null(sep)){\n    separator <- sep\n    if(length(unlist(strsplit(toCheck[1], separator)))\n       == length(unlist(strsplit(toCheck[2], separator))) - 1){\n      header <- TRUE\n      colNames <- gsub(\"\\\"\", \"\",\n                       unlist(strsplit(toCheck[1], separator)))\n      skip <- 0\n      rowNames <- getRowNames(file.name, separator, header, skip)\n    }else{\n      headerNSkip <- guess.header(toCheck[1:2], separator)\n      header <- headerNSkip[[\"header\"]]\n      skip <- headerNSkip[[\"skip\"]] \n      colNames <- headerNSkip[[\"colNames\"]]\n      rowNames <- getRowNames(file.name, separator, header, skip)\n    }\n    type <- find.type(file.name, separator, header, numLine)\n    return(list(header = header, separator = separator, skip = skip,\n                col.names = colNames, row.names = rowNames, type = type))\n  }else{\n    # New line is always the separator\n    return(list(header = FALSE, separator = \"\\n\", col.names = NA,\n                row.names = NA, skip = 0,\n                type = find.type(file.name, sep = \"\\n\", header = FALSE)))\n  }\n}\ngetRowNames <- function(file.name, sep, header, skip){\n  #data <- read.table(file.name, sep = sep, nrow = 3, header = header,\n            #         skip = skip)\n  data <- read.csv(file.name, sep = sep, nrow = 3, header = header,\n                              skip = skip)\n  return(rownames(data))\n}\n# A wraper of the file function that checks to see if a given file\n# name does exist.\n\nsafeFileOpen <- function(fileName) {\n  \n  if (file.exists(fileName)){\n    info <- file.info(fileName)\n    if(info$isdir){\n      return(paste(fileName, \"is a directory\"))\n    }\n    if(file.access(fileName, mode = 4) != 0){\n      return(paste(\"You don't have read permission to file\", fileName))\n    }\n    if(regexpr(\"\\\\.rda$|\\\\.Rda$\", fileName) > 0){\n      if(readLines(fileName, n = 1) == \"RDX2\"){\n        return(paste(fileName, \"is a binary file\"))\n      }else{\n        return(file(fileName))\n      }\n    }\n    if(regexpr(\"\\\\.gz\", fileName) > 0){\n      return(gzfile(fileName))\n    }else if(regexpr(\"\\\\.zip\", fileName) > 0){\n      return(unz(fileName))\n    }else if(regexpr(\"\\\\.bz2\", fileName) > 0 ){\n      return(bzfile(fileName))\n    }else{\n      return(file(fileName))\n    }\n  }else\n    return(paste(fileName,\"doest not exist\"))\n}\nguess.header <- function(twoLines, sep){\n  \n  on.exit(options(warn = 1))\n  \n  if(!is.null(sep)){\n    firstLine <- unlist(strsplit(twoLines[1], sep))\n    scndLine <- unlist(strsplit(twoLines[2], sep))\n  }else{\n    firstLine <- twoLines[1]\n    scndLine <- twoLines[2]\n  }\n  \n  options(warn = -1)\n  firstLine <- as.numeric(firstLine)\n  scndLine <- as.numeric(scndLine)\n  options(warn = 1)\n  \n  firstLine[!is.na(firstLine)] <- \"num\"\n  scndLine[!is.na(scndLine)] <- \"num\"\n  \n  if(!setequal(firstLine, scndLine)){\n    return(list(header = TRUE, skip = 1,\n                colNames = gsub(\"\\\"\", \"\",  unlist(strsplit(twoLines[1], sep)))))\n  }else{\n    #if(any(!is.na(firstLine))){\n    #    return(list(header = FALSE, skip = 0))\n    #}\n    return(list(header = FALSE, skip = 0, colNames = NA))\n  }\n}\n\nfind.type <- function(file.name, sep, header = FALSE, numLine = 5,\n                      isFile = TRUE){\n  if(isFile){\n    line <- as.matrix(read.csv(file.name, sep = sep, header = header,\n                                 nrows = numLine, as.is = TRUE))\n  }else{\n    line <- as.matrix(file.name)\n  }\n  \n  types <- NULL\n  for(i in 1:nrow(line)){\n    types <- rbind(types, charOrNum(line[i,]))\n  }\n  if(nrow(unique(types)) == 1){\n    return(types[1,])\n  }else{\n    return(rep(\"Character\", ncol(types)))\n  }\n}\n\ncharOrNum <- function(vect){\n  options(warn = -1)\n  temp <- as.numeric(vect)\n  options(warn = 1)\n  \n  temp[is.na(temp)] <- \"Character\"\n  temp[!is.na(temp) & temp != \"Character\"] <- \"Numeric\"\n  return(temp)\n}\n\n##########################################################\n#\n# Limpieza de datos most frequent\n##########################################################\n\nstatistic_clean <- function(x,method) {\n  \n  if(method == 'most_frecuent'){\n    \n    \n  }\n  \n  if(method == 'min'){\n    \n    \n  }\n  \n  if(method == 'max'){\n    \n    \n  }\n  \n  if(method == 'replace_with'){\n    \n    \n  }\n  \n  if (is.numeric(x)) {\n    x[is.na(x)] <- mean(x, na.rm = TRUE)\n    x\n  } else {\n    x[is.na(x)] <- names(which.max(table(x)))\n    x\n  }\n}\n\n\n\n\n##########################################################\n#\n# GEneracion de imagenes de sumarizacion\n##########################################################\n\ngenerateImage<-function(data){\n  outfile <- tempfile(tmpdir = \"D:\\\\data\\\\R\\\\win-library\\\\3.2\\\\shiny\\\\www\\\\shared\\\\tempImages\",fileext='.png')\n  \n  # Generate the PNG\n  png(outfile, width=400, height=300)\n  hist(data, main=\"Generated in renderImage()\")\n  dev.off()\n  outfile\n  \n  \n}\n\ndraw_tree<-function (model, main = \"\", sub, palettes, ...) \n{\n  if (missing(sub)) \n    sub <- paste(\"Rattle\", format(Sys.time(), \"%Y-%b-%d %H:%M:%S\"), \n                 Sys.info()[\"user\"])\n  num.classes <- length(attr(model, \"ylevels\"))\n  default.palettes <- c(\"Greens\", \"Blues\", \"Oranges\", \"Purples\", \n                        \"Reds\", \"Greys\")\n  if (missing(palettes)) \n    palettes <- default.palettes\n  missed <- setdiff(1:6, seq(length(palettes)))\n  palettes <- c(palettes, default.palettes[missed])\n  numpals <- 6\n  palsize <- 5\n  pals <- c(RColorBrewer::brewer.pal(9, palettes[1])[1:5], \n            RColorBrewer::brewer.pal(9, palettes[2])[1:5], RColorBrewer::brewer.pal(9, \n                                                                                    palettes[3])[1:5], RColorBrewer::brewer.pal(9, palettes[4])[1:5], \n            RColorBrewer::brewer.pal(9, palettes[5])[1:5], RColorBrewer::brewer.pal(9, \n                                                                                    palettes[6])[1:5])\n  if (model$method == \"class\") {\n    yval2per <- -(1:num.classes) - 1\n    per <- apply(model$frame$yval2[, yval2per], 1, function(x) x[1 + \n                                                                   x[1]])\n  }\n  else {\n    per <- model$frame$yval/max(model$frame$yval)\n  }\n  per <- as.numeric(per)\n  if (model$method == \"class\") \n    col.index <- ((palsize * (model$frame$yval - 1) + trunc(pmin(1 + \n                                                                   (per * palsize), palsize)))%%(numpals * palsize))\n  else col.index <- round(per * (palsize - 1)) + 1\n  col.index <- abs(col.index)\n  if (model$method == \"class\") \n    extra <- 104\n  else extra <- 101\n  rpart.plot::prp(model, type = 2, extra = extra, box.col = pals[col.index], \n                  nn = TRUE, varlen = 0, faclen = 0, shadow.col = \"grey\", \n                  fallen.leaves = TRUE, branch.lty = 3, ...)\n  title(main = main, sub = sub)\n}",
    "created" : 1447256452613.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4112754436",
    "id" : "B0D9C026",
    "lastKnownWriteTime" : 1461252123,
    "last_content_update" : 1461252123089,
    "path" : "C:/Users/KeyData/Desktop/OperacionesInusuales/OperacionesInusuales/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}